<?php namespace BasePlugin;

class Updater {

	/** @var string */
	protected $username = 'bitbucket_user';

	/** @var string */
	protected $password = 'bitbucket_password';

	/** @var string */
	protected $api_key = 'bitbucket_api_key';

	/** @var string */
	protected $repository_path = 'bitbucket_team_or_user/bitbucket_repo_name';

	/**
	 * The latest tag returned from vcs.
	 *
	 * @var  array
	 */
	protected $tag;

	/**
	 * The latest published-at date returned from vcs.
	 *
	 * @var  string
	 */
	protected $published;

	/**
	 * The array of data available about the current plugin.
	 *
	 * Generated by using the get_plugin_data() wordpress function.
	 *
	 * @var array
	 */
	protected $pluginData;

	/**
	 * The slug of the current plugin.
	 *
	 * Generated by using the plugin_basename() wordpress function.
	 *
	 * @var string
	 */
	protected $slug;

	/**
	 * The name of the base plugin file name, passed into the constructor.
	 *
	 * @var  string
	 */
	protected $pluginFile;

	/**
	 * Where to download the latest package.
	 *
	 * @var  string
	 */
	protected $downloadUrl;

	/**
	 * Sets base plugin filename.
	 *
	 * @param string $pluginFile
	 */
	function __construct( $pluginFile ) {
		$this->pluginFile = $pluginFile;

	}

	public function init() {

		// Un-comment to test - makes WP check every time for new plugins
		// delete_option( '_site_transient_update_plugins' );

		add_filter( 'pre_set_site_transient_update_plugins', [ $this, 'setTransient' ] );
		add_filter( 'plugins_api', [ $this, 'setPluginPopupInfo' ], 10, 3 );
		add_filter( 'upgrader_source_selection', [ $this, 'alterDirectoryNameDuringUpgrade' ], 10, 4 );

		// intercept bitbucket request and add basic auth
		add_filter( 'http_request_args', [ $this, 'authenticateHttp' ], 10, 2 );

	}

	/**
	 * Retrieve latest info about plugin from vcs.
	 */
	protected function getLatestBitbucketInfo() {
		$url = "https://api.bitbucket.org/1.0/repositories/{$this->repository_path}/tags";

		$args = [
			'headers' => [
				'Authorization' => 'Basic ' . base64_encode( "rddev:{$this->api_key}" )
			]
		];

		$response = wp_remote_get( $url, $args );
		$json     = wp_remote_retrieve_body( $response );
		if ( ! empty( $json ) ) {
			$results           = json_decode( $json, true );
			$this->tag         = $this->getHighestTag( array_keys( $results ) );
			$this->published   = $results[ $this->tag ]['timestamp'];
			$this->downloadUrl = "https://bitbucket.org/{$this->repository_path}/get/{$this->tag}.zip";
		}

	}

	protected function getHighestTag( array $tags ) {
		usort($tags, 'version_compare');
		return end($tags);
	}

	/**
	 * Set the data about this plugin using built in wordpress functions.
	 */
	public function getWordpressPluginData() {
		$this->pluginData = get_plugin_data( $this->pluginFile );
		$this->slug       = plugin_basename( $this->pluginFile );
	}

	/**
	 * Function used as callback to the 'pre_set_site_transient_update_plugins' hook.
	 *
	 * Checks current plugin version number against vcs latest.
	 *
	 * If update is required then fills out the response object with the latest data for the file.
	 *
	 * @param mixed $transient Value of 'update_plugins' site transient.
	 *
	 * @return mixed Updated value of 'update_plugins' site transient.
	 */
	public function setTransient( $transient ) {

		//If we have checked the plugin data before, don't re-check
		if ( empty( $transient->checked ) ) {
			return $transient;
		}

		// Gather info
		$this->getWordpressPluginData();
		$this->getLatestBitbucketInfo();

		$updateRequired = version_compare( $this->tag, $transient->checked[ $this->slug ] );

		if ( 1 === $updateRequired ) {

			$obj              = new \stdClass();
			$obj->slug        = dirname( $this->slug );
			$obj->plugin      = $this->slug;
			$obj->new_version = $this->tag;
			$obj->url         = $this->pluginData["PluginURI"];
			$obj->package     = $this->downloadUrl;

			$transient->response[ $this->slug ] = $obj;

		}

		return $transient;
	}

	/**
	 * Method used as callback for the 'plugins_api' hook.
	 *
	 * Fills out the information shown when a plugin update is available.
	 *
	 * @param bool|object $false The result object. Default false.
	 * @param string $action The type of information being requested from the Plugin Install API.
	 * @param object $args Plugin API arguments.
	 *
	 * @return bool|object Updated Plugin API arguments.
	 */
	public function setPluginPopupInfo( $false, $action, $args ) {

		// Gather info
		$this->getWordpressPluginData();

		$this->slug = dirname( $this->slug );

		// is it our turn to respond
		if ( empty( $args->slug ) || $args->slug != $this->slug ) {
			return $false;
		}

		$this->getLatestBitbucketInfo();

		// Add our plugin information
		$args->slug              = $this->slug;
		$args->name              = $this->pluginData["Name"];
		$args->author            = $this->pluginData["AuthorName"];
		$args->version           = $this->tag;
		$args->homepage          = $this->pluginData["PluginURI"];
		$args->downloadLink      = $this->downloadUrl;
		$args->last_updated      = $this->published;
		$args->short_description = $this->pluginData["Description"];

		$args->sections = [
			'description' => $this->pluginData["Description"],
		];

		return $args;

	}


	/**
	 * Intercept bitbucket requests and add basic auth
	 *
	 * @param $args
	 * @param $url
	 *
	 * @return array
	 */
	public function authenticateHttp( $args, $url ) {
		if ( false === stristr( $url, $this->repository_path ) ) {
			return $args;
		}

		$args['headers']['Authorization'] = 'Basic ' . base64_encode( "{$this->username}:{$this->password}" );

		return $args;
	}

	/**
	 * Method called during plugin update, after file has been downloaded to the upgrage folder.
	 * Used here to rename the containing directory from it's mad bitbucket name to what we actually want it to be.
	 *
	 * @param string $source
	 * @param string $remote_source
	 * @param \Plugin_Upgrader $upgrader
	 * @param array $hook_extra Extra arguments passed to hooked filters.
	 *
	 * @return mixed
	 *
	 */
	public function alterDirectoryNameDuringUpgrade( $source, $remote_source, $upgrader, $hook_extra ) {

		if ( is_wp_error( $source ) ) {
			return $source;
		}

		if ( ! ( $upgrader instanceof \Plugin_Upgrader ) ) {
			return $source;
		}

		if ( strpos( $source, basename( $this->repository_path) ) === false ) {
			return $source;
		}

		global $wp_filesystem;

		$new_source = trailingslashit( $remote_source ) . dirname( plugin_basename( $this->pluginFile ) );

		$wp_filesystem->move( $source, $new_source );

		return trailingslashit( $new_source );
	}

}